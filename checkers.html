<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draughts Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            color: #fdbb2d;
        }
        
        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 20px;
            opacity: 0.9;
        }
        
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 12px 25px;
            font-size: 1rem;
            font-weight: bold;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(to right, #ff7e5f, #feb47b);
            color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        button.active {
            background: linear-gradient(to right, #00b09b, #96c93d);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        }
        
        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .player-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }
        
        .player1 {
            background-color: #ff5252;
        }
        
        .player2 {
            background-color: #333;
        }
        
        .king {
            background-color: #ffeb3b !important;
            color: #333 !important;
        }
        
        .game-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1/1;
            margin: 0 auto;
            border: 10px solid #5d4037;
            border-radius: 5px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
        }
        
        .cell {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .dark {
            background-color: #8d6e63;
        }
        
        .light {
            background-color: #d7ccc8;
        }
        
        .piece {
            width: 80%;
            height: 80%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .piece.player1 {
            background: radial-gradient(circle at 30% 30%, #ff5252, #b71c1c);
            color: white;
        }
        
        .piece.player2 {
            background: radial-gradient(circle at 30% 30%, #424242, #212121);
            color: white;
        }
        
        .piece.king {
            background: radial-gradient(circle at 30% 30%, #ffeb3b, #fbc02d);
            color: #333;
        }
        
        .piece.selected {
            box-shadow: 0 0 0 3px #00e676, 0 0 15px #00e676;
        }
        
        .valid-move {
            position: absolute;
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background-color: rgba(0, 230, 118, 0.5);
            z-index: 1;
        }
        
        .capture-move {
            position: absolute;
            width: 25%;
            height: 25%;
            border-radius: 50%;
            background-color: rgba(255, 0, 0, 0.5);
            z-index: 1;
        }
        
        .game-status {
            text-align: center;
            margin-top: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            min-height: 30px;
        }
        
        .instructions {
            margin-top: 30px;
            padding: 15px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            font-size: 0.9rem;
        }
        
        .instructions h3 {
            margin-bottom: 10px;
            color: #ffeb3b;
        }
        
        .instructions ul {
            padding-left: 20px;
        }
        
        .instructions li {
            margin-bottom: 8px;
        }
        
        @media (max-width: 600px) {
            .game-board {
                max-width: 350px;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .game-controls {
                flex-direction: column;
                align-items: center;
            }
            
            button {
                width: 100%;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>DR<span style="color: #ff5252;">A</span>UGHTS</h1>
            <p class="subtitle">The Classic Checkers Game</p>
        </header>
        
        <div class="game-controls">
            <button id="singlePlayerBtn">Single Player</button>
            <button id="multiPlayerBtn">Multiplayer</button>
            <button id="resetBtn">Reset Game</button>
        </div>
        
        <div class="game-info">
            <div class="player-info">
                <div class="player-icon player1">P1</div>
                <span>Player 1 (Red)</span>
            </div>
            <div class="player-info">
                <div class="player-icon player2">P2</div>
                <span>Player 2 (Black)</span>
            </div>
        </div>
        
        <div class="game-board" id="gameBoard">
            <!-- Board will be generated by JavaScript -->
        </div>
        
        <div class="game-status" id="gameStatus">
            Player 1's turn
        </div>
        
        <div class="instructions">
            <h3>How to Play</h3>
            <ul>
                <li>Click on your piece to select it, then click on a highlighted square to move</li>
                <li>Pieces move diagonally forward one square</li>
                <li>Capture opponent pieces by jumping over them</li>
                <li>If a piece reaches the opposite end, it becomes a King (with crown)</li>
                <li>Kings can move diagonally in any direction</li>
                <li>You must capture if a capture is available</li>
            </ul>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game state variables
            let board = [];
            let currentPlayer = 1;
            let selectedPiece = null;
            let validMoves = [];
            let gameMode = 'multiplayer'; // 'single' or 'multiplayer'
            let gameActive = true;
            
            // DOM elements
            const gameBoard = document.getElementById('gameBoard');
            const gameStatus = document.getElementById('gameStatus');
            const singlePlayerBtn = document.getElementById('singlePlayerBtn');
            const multiPlayerBtn = document.getElementById('multiPlayerBtn');
            const resetBtn = document.getElementById('resetBtn');
            
            // Initialize the game
            function initGame() {
                createBoard();
                setupEventListeners();
                updateGameStatus();
            }
            
            // Create the game board
            function createBoard() {
                // Clear the board
                gameBoard.innerHTML = '';
                board = [];
                
                // Create 8x8 board
                for (let row = 0; row < 8; row++) {
                    board[row] = [];
                    for (let col = 0; col < 8; col++) {
                        // Create cell
                        const cell = document.createElement('div');
                        cell.className = `cell ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // Add pieces to starting positions
                        if ((row + col) % 2 !== 0) {
                            if (row < 3) {
                                // Player 2 pieces (top)
                                board[row][col] = { player: 2, isKing: false };
                            } else if (row > 4) {
                                // Player 1 pieces (bottom)
                                board[row][col] = { player: 1, isKing: false };
                            } else {
                                board[row][col] = null;
                            }
                        } else {
                            board[row][col] = null;
                        }
                        
                        gameBoard.appendChild(cell);
                    }
                }
                
                renderBoard();
            }
            
            // Render the board with pieces
            function renderBoard() {
                const cells = document.querySelectorAll('.cell');
                
                cells.forEach(cell => {
                    // Clear any existing pieces or markers
                    const existingPiece = cell.querySelector('.piece');
                    const existingMarker = cell.querySelector('.valid-move, .capture-move');
                    
                    if (existingPiece) existingPiece.remove();
                    if (existingMarker) existingMarker.remove();
                    
                    const row = parseInt(cell.dataset.row);
                    const col = parseInt(cell.dataset.col);
                    const piece = board[row][col];
                    
                    // Add piece if exists
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = `piece player${piece.player}`;
                        if (piece.isKing) {
                            pieceElement.classList.add('king');
                            pieceElement.innerHTML = '<i class="fas fa-crown"></i>';
                        }
                        
                        if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                            pieceElement.classList.add('selected');
                        }
                        
                        cell.appendChild(pieceElement);
                    }
                });
                
                // Add valid move indicators
                validMoves.forEach(move => {
                    const cell = document.querySelector(`.cell[data-row="${move.row}"][data-col="${move.col}"]`);
                    if (cell) {
                        const marker = document.createElement('div');
                        marker.className = move.isCapture ? 'capture-move' : 'valid-move';
                        cell.appendChild(marker);
                    }
                });
            }
            
            // Set up event listeners
            function setupEventListeners() {
                // Game mode buttons
                singlePlayerBtn.addEventListener('click', () => {
                    gameMode = 'single';
                    singlePlayerBtn.classList.add('active');
                    multiPlayerBtn.classList.remove('active');
                    resetGame();
                });
                
                multiPlayerBtn.addEventListener('click', () => {
                    gameMode = 'multiplayer';
                    multiPlayerBtn.classList.add('active');
                    singlePlayerBtn.classList.remove('active');
                    resetGame();
                });
                
                // Reset button
                resetBtn.addEventListener('click', resetGame);
                
                // Board click handler
                gameBoard.addEventListener('click', handleBoardClick);
            }
            
            // Handle board clicks
            function handleBoardClick(event) {
                if (!gameActive) return;
                
                const cell = event.target.closest('.cell');
                if (!cell) return;
                
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                // If a piece is already selected
                if (selectedPiece) {
                    // Check if the clicked cell is a valid move
                    const isValidMove = validMoves.some(move => 
                        move.row === row && move.col === col
                    );
                    
                    if (isValidMove) {
                        // Move the piece
                        movePiece(selectedPiece.row, selectedPiece.col, row, col);
                        
                        // Reset selection
                        selectedPiece = null;
                        validMoves = [];
                        
                        // Render the updated board
                        renderBoard();
                        
                        // Check for game over
                        if (checkGameOver()) {
                            gameActive = false;
                            return;
                        }
                        
                        // If in single player mode and it's the AI's turn
                        if (gameMode === 'single' && currentPlayer === 2) {
                            setTimeout(makeAIMove, 500);
                        }
                    } else {
                        // If clicking on another piece of the same player
                        const piece = board[row][col];
                        if (piece && piece.player === currentPlayer) {
                            selectedPiece = { row, col };
                            validMoves = getValidMoves(row, col);
                            renderBoard();
                        } else {
                            // Deselect if clicking elsewhere
                            selectedPiece = null;
                            validMoves = [];
                            renderBoard();
                        }
                    }
                } else {
                    // Select a piece if it belongs to the current player
                    const piece = board[row][col];
                    if (piece && piece.player === currentPlayer) {
                        selectedPiece = { row, col };
                        validMoves = getValidMoves(row, col);
                        renderBoard();
                    }
                }
            }
            
            // Get valid moves for a piece
            function getValidMoves(row, col) {
                const piece = board[row][col];
                if (!piece) return [];
                
                const moves = [];
                const directions = [];
                
                // Determine movement directions based on piece type
                if (piece.isKing) {
                    // Kings can move in all four diagonal directions
                    directions.push([-1, -1], [-1, 1], [1, -1], [1, 1]);
                } else {
                    // Regular pieces can only move forward
                    if (piece.player === 1) {
                        directions.push([-1, -1], [-1, 1]); // Up
                    } else {
                        directions.push([1, -1], [1, 1]); // Down
                    }
                }
                
                // Check for regular moves and captures
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    // Check if the new position is within the board
                    if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                        // If the cell is empty, it's a valid move
                        if (!board[newRow][newCol]) {
                            moves.push({ row: newRow, col: newCol, isCapture: false });
                        } 
                        // If the cell contains an opponent's piece, check if we can capture
                        else if (board[newRow][newCol].player !== piece.player) {
                            const jumpRow = newRow + dr;
                            const jumpCol = newCol + dc;
                            
                            // Check if the jump position is within the board and empty
                            if (jumpRow >= 0 && jumpRow < 8 && jumpCol >= 0 && jumpCol < 8 && !board[jumpRow][jumpCol]) {
                                moves.push({ row: jumpRow, col: jumpCol, isCapture: true, capturedRow: newRow, capturedCol: newCol });
                            }
                        }
                    }
                }
                
                // Check for multiple captures
                const captureMoves = moves.filter(move => move.isCapture);
                if (captureMoves.length > 0) {
                    // If there are captures, only return capture moves (mandatory capture rule)
                    return captureMoves;
                }
                
                return moves;
            }
            
            // Move a piece from one position to another
            function movePiece(fromRow, fromCol, toRow, toCol) {
                const piece = board[fromRow][fromCol];
                
                // Move the piece
                board[toRow][toCol] = piece;
                board[fromRow][fromCol] = null;
                
                // Check if the move was a capture
                const move = validMoves.find(m => m.row === toRow && m.col === toCol);
                if (move && move.isCapture) {
                    // Remove the captured piece
                    board[move.capturedRow][move.capturedCol] = null;
                    
                    // Check for additional captures with the same piece
                    const additionalCaptures = getValidMoves(toRow, toCol).filter(m => m.isCapture);
                    
                    if (additionalCaptures.length > 0) {
                        // If there are additional captures, keep the turn with the same player
                        selectedPiece = { row: toRow, col: toCol };
                        validMoves = additionalCaptures;
                        renderBoard();
                        return; // Don't switch turns yet
                    }
                }
                
                // Check for king promotion
                if (!piece.isKing) {
                    if ((piece.player === 1 && toRow === 0) || (piece.player === 2 && toRow === 7)) {
                        piece.isKing = true;
                    }
                }
                
                // Switch players
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                selectedPiece = null;
                validMoves = [];
                
                updateGameStatus();
            }
            
            // AI move logic
            function makeAIMove() {
                if (!gameActive || currentPlayer !== 2) return;
                
                // Get all possible moves for AI pieces
                const allMoves = [];
                
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece && piece.player === 2) {
                            const moves = getValidMoves(row, col);
                            moves.forEach(move => {
                                allMoves.push({
                                    from: { row, col },
                                    to: { row: move.row, col: move.col },
                                    isCapture: move.isCapture,
                                    captured: move.isCapture ? { row: move.capturedRow, col: move.capturedCol } : null
                                });
                            });
                        }
                    }
                }
                
                // If no moves available, skip turn (shouldn't happen in normal game)
                if (allMoves.length === 0) {
                    currentPlayer = 1;
                    updateGameStatus();
                    return;
                }
                
                // Prioritize captures
                const captureMoves = allMoves.filter(move => move.isCapture);
                const movesToConsider = captureMoves.length > 0 ? captureMoves : allMoves;
                
                // For a more intelligent AI, we could evaluate moves based on:
                // 1. Capturing opponent pieces
                // 2. Protecting own pieces
                // 3. Advancing towards king row
                // 4. Controlling the center
                
                // For now, we'll randomly select from the best available moves
                // But prioritize moves that capture pieces and create kings
                const scoredMoves = movesToConsider.map(move => {
                    let score = 0;
                    
                    // Higher score for captures
                    if (move.isCapture) score += 10;
                    
                    // Higher score for moves that create kings
                    if (move.to.row === 7 && !board[move.from.row][move.from.col].isKing) score += 5;
                    
                    // Prefer moves that don't put pieces in danger
                    if (!isPositionVulnerable(move.to.row, move.to.col)) score += 2;
                    
                    // Prefer center control
                    if (move.to.col >= 2 && move.to.col <= 5) score += 1;
                    
                    return { move, score };
                });
                
                // Sort by score and pick one of the top moves
                scoredMoves.sort((a, b) => b.score - a.score);
                const topMoves = scoredMoves.filter(m => m.score === scoredMoves[0].score);
                const selectedMove = topMoves[Math.floor(Math.random() * topMoves.length)].move;
                
                // Execute the selected move
                selectedPiece = { row: selectedMove.from.row, col: selectedMove.from.col };
                validMoves = getValidMoves(selectedMove.from.row, selectedMove.from.col);
                
                // Simulate the move
                movePiece(selectedMove.from.row, selectedMove.from.col, selectedMove.to.row, selectedMove.to.col);
                renderBoard();
                
                // Check for game over
                if (checkGameOver()) {
                    gameActive = false;
                }
            }
            
            // Check if a position is vulnerable to capture
            function isPositionVulnerable(row, col) {
                const piece = board[row][col];
                if (!piece) return false;
                
                // Check if any opponent piece can capture this piece
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const opponentPiece = board[r][c];
                        if (opponentPiece && opponentPiece.player !== piece.player) {
                            const moves = getValidMoves(r, c);
                            if (moves.some(m => m.isCapture && m.capturedRow === row && m.capturedCol === col)) {
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            // Check if the game is over
            function checkGameOver() {
                let player1Pieces = 0;
                let player2Pieces = 0;
                let player1HasMoves = false;
                let player2HasMoves = false;
                
                // Count pieces and check for valid moves
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece) {
                            if (piece.player === 1) {
                                player1Pieces++;
                                if (!player1HasMoves) {
                                    player1HasMoves = getValidMoves(row, col).length > 0;
                                }
                            } else {
                                player2Pieces++;
                                if (!player2HasMoves) {
                                    player2HasMoves = getValidMoves(row, col).length > 0;
                                }
                            }
                        }
                    }
                }
                
                // Check for win conditions
                if (player1Pieces === 0 || !player1HasMoves) {
                    gameStatus.textContent = "Player 2 Wins!";
                    return true;
                }
                
                if (player2Pieces === 0 || !player2HasMoves) {
                    gameStatus.textContent = "Player 1 Wins!";
                    return true;
                }
                
                return false;
            }
            
            // Update game status display
            function updateGameStatus() {
                if (gameMode === 'single') {
                    gameStatus.textContent = currentPlayer === 1 ? 
                        "Your turn (Red)" : "AI is thinking...";
                } else {
                    gameStatus.textContent = currentPlayer === 1 ? 
                        "Player 1's turn (Red)" : "Player 2's turn (Black)";
                }
            }
            
            // Reset the game
            function resetGame() {
                currentPlayer = 1;
                selectedPiece = null;
                validMoves = [];
                gameActive = true;
                createBoard();
                updateGameStatus();
            }
            
            // Initialize the game
            initGame();
        });
    </script>
</body>
</html>