<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Sort Puzzle</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1200px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            width: 100%;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            background: linear-gradient(to right, #ff9966, #ff5e62);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
            padding: 10px 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .level-info, .moves-info {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .game-area {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
            width: 100%;
        }

        .tubes-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            max-width: 800px;
        }

        .tube {
            width: 80px;
            height: 300px;
            display: flex;
            flex-direction: column-reverse;
            align-items: center;
            cursor: pointer;
            border: 3px solid rgba(255, 255, 255, 0.7);
            border-bottom: 15px solid rgba(255, 255, 255, 0.7);
            border-radius: 10px 10px 40px 40px;
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            transition: transform 0.2s, border-color 0.2s;
        }

        .tube:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 255, 255, 0.9);
        }

        .tube.selected {
            transform: translateY(-10px);
            border-color: gold;
            box-shadow: 0 0 15px gold;
        }

        .water {
            width: 100%;
            height: 25%;
            transition: all 0.5s ease;
        }

        .tube-top {
            position: absolute;
            top: -5px;
            width: 90px;
            height: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            z-index: 1;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            width: 250px;
        }

        button {
            padding: 12px 20px;
            font-size: 1.1rem;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            background: linear-gradient(to right, #ff9966, #ff5e62);
            color: white;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(1px);
        }

        .instructions {
            margin-top: 30px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            max-width: 800px;
            line-height: 1.6;
        }

        .instructions h2 {
            margin-bottom: 15px;
            color: #ffcc00;
        }

        .instructions ul {
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 10px;
        }

        .level-complete {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .level-complete.active {
            opacity: 1;
            pointer-events: all;
        }

        .celebration {
            font-size: 4rem;
            margin-bottom: 20px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .message {
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-align: center;
        }

        .level-complete button {
            font-size: 1.5rem;
            padding: 15px 30px;
        }

        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }
            
            .tubes-container {
                max-width: 100%;
            }
            
            .tube {
                width: 60px;
                height: 220px;
            }
            
            .tube-top {
                width: 70px;
            }
            
            .controls {
                width: 100%;
                max-width: 400px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Water Sort Puzzle</h1>
            <p>Sort the colored water until each tube contains only one color</p>
        </header>
        
        <div class="game-info">
            <div class="level-info">Level: <span id="level">1</span></div>
            <div class="moves-info">Moves: <span id="moves">0</span></div>
        </div>
        
        <div class="game-area">
            <div class="tubes-container" id="tubes-container">
                <!-- Tubes will be generated here -->
            </div>
            
            <div class="controls">
                <button id="reset-btn">Reset Level</button>
                <button id="undo-btn">Undo Move</button>
                <button id="hint-btn">Hint</button>
                <button id="next-level-btn" disabled>Next Level</button>
            </div>
        </div>
        
        <div class="instructions">
            <h2>How to Play</h2>
            <ul>
                <li>Click on a tube to select it</li>
                <li>Click on another tube to pour water from the selected tube</li>
                <li>You can only pour water if the target tube has enough space and the top colors match</li>
                <li>Empty tubes can receive any color</li>
                <li>Complete the level by sorting all colors into separate tubes</li>
            </ul>
        </div>
        
        <div class="level-complete" id="level-complete">
            <div class="celebration">ðŸŽ‰</div>
            <div class="message">Level Complete!</div>
            <button id="continue-btn">Continue</button>
        </div>
    </div>

    <script>
        // Game state
        const gameState = {
            level: 1,
            moves: 0,
            selectedTube: null,
            tubes: [],
            moveHistory: [],
            levels: [
                // Level 1
                {
                    tubes: [
                        ['red', 'red', 'blue', 'blue'],
                        ['blue', 'red', 'blue', 'red'],
                        [],
                        []
                    ]
                },
                // Level 2
                {
                    tubes: [
                        ['red', 'green', 'blue', 'green'],
                        ['blue', 'red', 'green', 'blue'],
                        ['red', 'blue', 'green', 'red'],
                        [],
                        []
                    ]
                },
                // Level 3
                {
                    tubes: [
                        ['red', 'yellow', 'blue', 'green'],
                        ['green', 'red', 'yellow', 'blue'],
                        ['blue', 'green', 'red', 'yellow'],
                        ['yellow', 'blue', 'green', 'red'],
                        [],
                        []
                    ]
                }
            ]
        };

        // DOM elements
        const tubesContainer = document.getElementById('tubes-container');
        const levelElement = document.getElementById('level');
        const movesElement = document.getElementById('moves');
        const resetBtn = document.getElementById('reset-btn');
        const undoBtn = document.getElementById('undo-btn');
        const hintBtn = document.getElementById('hint-btn');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const levelComplete = document.getElementById('level-complete');
        const continueBtn = document.getElementById('continue-btn');

        // Initialize the game
        function initGame() {
            loadLevel(gameState.level);
            updateUI();
            setupEventListeners();
        }

        // Load a specific level
        function loadLevel(level) {
            const levelData = gameState.levels[level - 1];
            if (!levelData) {
                // If no more levels, show completion message
                levelComplete.querySelector('.message').textContent = 'All Levels Completed!';
                levelComplete.classList.add('active');
                return;
            }
            
            gameState.tubes = JSON.parse(JSON.stringify(levelData.tubes));
            gameState.moves = 0;
            gameState.selectedTube = null;
            gameState.moveHistory = [];
            
            renderTubes();
            updateUI();
        }

        // Render tubes in the container
        function renderTubes() {
            tubesContainer.innerHTML = '';
            
            gameState.tubes.forEach((tube, index) => {
                const tubeElement = document.createElement('div');
                tubeElement.className = 'tube';
                tubeElement.dataset.index = index;
                
                // Add tube top
                const tubeTop = document.createElement('div');
                tubeTop.className = 'tube-top';
                tubeElement.appendChild(tubeTop);
                
                // Add water layers
                for (let i = 0; i < 4; i++) {
                    const water = document.createElement('div');
                    water.className = 'water';
                    
                    if (i < tube.length) {
                        water.style.backgroundColor = getColorCode(tube[i]);
                    } else {
                        water.style.backgroundColor = 'transparent';
                    }
                    
                    tubeElement.appendChild(water);
                }
                
                tubesContainer.appendChild(tubeElement);
            });
        }

        // Get color code from color name
        function getColorCode(color) {
            const colors = {
                'red': '#ff4757',
                'blue': '#3742fa',
                'green': '#2ed573',
                'yellow': '#ffa502',
                'purple': '#a55eea',
                'orange': '#ff9f1a',
                'pink': '#ff6b81',
                'cyan': '#17c0eb'
            };
            
            return colors[color] || '#ffffff';
        }

        // Setup event listeners
        function setupEventListeners() {
            // Tube click events
            tubesContainer.addEventListener('click', handleTubeClick);
            
            // Button events
            resetBtn.addEventListener('click', () => {
                loadLevel(gameState.level);
            });
            
            undoBtn.addEventListener('click', undoMove);
            
            hintBtn.addEventListener('click', showHint);
            
            nextLevelBtn.addEventListener('click', () => {
                gameState.level++;
                loadLevel(gameState.level);
                nextLevelBtn.disabled = true;
            });
            
            continueBtn.addEventListener('click', () => {
                levelComplete.classList.remove('active');
                nextLevelBtn.disabled = false;
            });
        }

        // Handle tube click
        function handleTubeClick(e) {
            const tubeElement = e.target.closest('.tube');
            if (!tubeElement) return;
            
            const tubeIndex = parseInt(tubeElement.dataset.index);
            
            // If no tube is selected, select this one
            if (gameState.selectedTube === null) {
                // Only select non-empty tubes
                if (gameState.tubes[tubeIndex].length > 0) {
                    gameState.selectedTube = tubeIndex;
                    tubeElement.classList.add('selected');
                }
            } 
            // If the same tube is clicked again, deselect it
            else if (gameState.selectedTube === tubeIndex) {
                gameState.selectedTube = null;
                tubeElement.classList.remove('selected');
            } 
            // If a different tube is clicked, try to pour
            else {
                const sourceIndex = gameState.selectedTube;
                const targetIndex = tubeIndex;
                
                // Save current state for undo
                gameState.moveHistory.push({
                    tubes: JSON.parse(JSON.stringify(gameState.tubes)),
                    moves: gameState.moves
                });
                
                // Try to pour
                if (pourWater(sourceIndex, targetIndex)) {
                    gameState.moves++;
                    
                    // Check if level is complete
                    if (isLevelComplete()) {
                        levelComplete.classList.add('active');
                        nextLevelBtn.disabled = false;
                    }
                }
                
                // Deselect the tube
                document.querySelector(`.tube[data-index="${sourceIndex}"]`).classList.remove('selected');
                gameState.selectedTube = null;
                
                updateUI();
            }
        }

        // Pour water from source to target tube
        function pourWater(sourceIndex, targetIndex) {
            const sourceTube = gameState.tubes[sourceIndex];
            const targetTube = gameState.tubes[targetIndex];
            
            // Check if source tube is empty
            if (sourceTube.length === 0) return false;
            
            // Check if target tube is full
            if (targetTube.length === 4) return false;
            
            // Get the top color from source tube
            const topColor = sourceTube[sourceTube.length - 1];
            
            // Check if target tube is empty or has the same top color
            if (targetTube.length > 0 && targetTube[targetTube.length - 1] !== topColor) {
                return false;
            }
            
            // Calculate how much water we can pour
            let pourAmount = 1;
            
            // Check how many consecutive same colors are at the top of source tube
            for (let i = sourceTube.length - 2; i >= 0; i--) {
                if (sourceTube[i] === topColor) {
                    pourAmount++;
                } else {
                    break;
                }
            }
            
            // Adjust pour amount based on available space in target tube
            pourAmount = Math.min(pourAmount, 4 - targetTube.length);
            
            // Pour the water
            for (let i = 0; i < pourAmount; i++) {
                targetTube.push(sourceTube.pop());
            }
            
            // Re-render tubes
            renderTubes();
            
            return true;
        }

        // Check if level is complete
        function isLevelComplete() {
            for (const tube of gameState.tubes) {
                // If tube is not empty and not full of same color, level is not complete
                if (tube.length > 0) {
                    const color = tube[0];
                    for (let i = 1; i < tube.length; i++) {
                        if (tube[i] !== color) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        // Undo the last move
        function undoMove() {
            if (gameState.moveHistory.length === 0) return;
            
            const lastState = gameState.moveHistory.pop();
            gameState.tubes = lastState.tubes;
            gameState.moves = lastState.moves;
            
            renderTubes();
            updateUI();
        }

        // Show a hint
        function showHint() {
            // Simple hint system - highlight a valid move
            for (let i = 0; i < gameState.tubes.length; i++) {
                const sourceTube = gameState.tubes[i];
                if (sourceTube.length === 0) continue;
                
                const topColor = sourceTube[sourceTube.length - 1];
                
                for (let j = 0; j < gameState.tubes.length; j++) {
                    if (i === j) continue;
                    
                    const targetTube = gameState.tubes[j];
                    
                    // Check if this is a valid move
                    if (targetTube.length < 4 && 
                        (targetTube.length === 0 || targetTube[targetTube.length - 1] === topColor)) {
                        
                        // Highlight the tubes
                        const sourceElement = document.querySelector(`.tube[data-index="${i}"]`);
                        const targetElement = document.querySelector(`.tube[data-index="${j}"]`);
                        
                        sourceElement.style.borderColor = 'gold';
                        targetElement.style.borderColor = 'gold';
                        
                        setTimeout(() => {
                            sourceElement.style.borderColor = '';
                            targetElement.style.borderColor = '';
                        }, 2000);
                        
                        return;
                    }
                }
            }
        }

        // Update UI elements
        function updateUI() {
            levelElement.textContent = gameState.level;
            movesElement.textContent = gameState.moves;
            
            // Enable/disable undo button
            undoBtn.disabled = gameState.moveHistory.length === 0;
        }

        // Initialize the game when page loads
        window.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>